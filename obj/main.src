; Zilog eZ80 ANSI C Compiler Release 3.4
; -optsize -noreduceopt -nomodsect -peephole -globalopt
; -localcse -const=ROM 
	FILE	"SRC\MAIN.C"
	.assume ADL=1
	SEGMENT DATA
_xPos:
	DW	100
	DB	0
_yPos:
	DW	100
	DB	0
_squareSize:
	DW	10
	DB	0
	SEGMENT BSS
_key:
	DS	1
	SEGMENT DATA
_fruitX:
	DW	0
	DB	0
_fruitY:
	DW	0
	DB	0
_segments:
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
	DW	0
	DB	0
_noSegments:
	DW	1
	DB	0
_maxSegments:
	DW	100
	DB	0
	SEGMENT BSS
_debugBuffer:
	DS	20
	SEGMENT DATA
_i:
	DW	0
	DB	0
	SEGMENT BSS
_currentDir:
	DS	3
;    1	/*
;    2	 *--------------------------------------
;    3	 * Program Name: Snake for CE
;    4	 * Author: Malcolm Anderson
;    5	 * License: uuhhhhh idk
;    6	 * Description: It's Snake. For the CE.
;    7	 *--------------------------------------
;    8	*/
;    9	
;   10	/* Keep these headers */
;   11	#include <stdbool.h>
;   12	#include <stddef.h>
;   13	#include <stdint.h>
;   14	#include <tice.h>
;   15	
;   16	/* Standard headers (recommended) */
;   17	#include <math.h>
;   18	#include <stdio.h>
;   19	#include <stdlib.h>
;   20	#include <string.h>
;   21	
;   22	#include <graphx.h>
;   23	#include <debug.h>
;   24	#include <keypadc.h>
;   25	
;   26	#define SCREEN_MAX_X 320
;   27	#define SCREEN_MAX_Y 240
;   28	
;   29	/* Put your function prototypes here */
;   30	void generateFruit(void);
;   31	void shiftSegments(void);
;   32	/* Put all your globals here */
;   33	
;   34	int xPos = 100;
;   35	int yPos = 100;
;   36	int squareSize = 10;
;   37	kb_key_t key;
;   38	
;   39	int fruitX = 0;
;   40	int fruitY = 0;
;   41	
;   42	int segments[2][100] = 0;
;   43	unsigned int noSegments = 1;
;   44	unsigned int maxSegments = 100;
;   45	char debugBuffer[20];
;   46	
;   47	int i = 0; // for iterations
;   48	
;   49	enum Direction {
;   50	    Up = 0,
;   51	    Right = 1,
;   52	    Down = 2,
;   53	    Left = 3
;   54	};
;   55	
;   56	enum Direction currentDir;
	SEGMENT CODE
;   57	
;   58	void main(void) {
_main:
	LD	HL,-18
	CALL	__frameset
;   59	    currentDir = Right;
	LD	BC,1
	LD	(_currentDir),BC
;   60	
;   61	    
;   62	    /* Fill in the body of the main function here */
;   63	
;   64	    gfx_Begin();
	CALL	_gfx_Begin
;   65	    gfx_SetDrawBuffer();
	LD	BC,1
	PUSH	BC
	CALL	_gfx_SetDraw
	POP	BC
;   66	    gfx_SetColor(gfx_white);
	LD	BC,255
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;   67	    gfx_SetTextFGColor(gfx_white);
	LD	BC,255
	PUSH	BC
	CALL	_gfx_SetTextFGColor
	POP	BC
;   68	
;   69	    generateFruit();
	CALL	_generateFruit
;   70	
;   71	    
;   72	    kb_Scan();
	CALL	_kb_Scan
;   73	
;   74	    do {
L_47:
;   75	        
;   76	        gfx_FillScreen(gfx_red);
	LD	BC,224
	PUSH	BC
	CALL	_gfx_FillScreen
	POP	BC
;   77	        // gfx_SetTextFGColor(gfx_white);
;   78	
;   79	        // sprintf(debugBuffer, "%d segments", noSegments);
;   80	        // // debugBuffer[0] = 'A';
;   81	        // // debugBuffer[1] = 'B';
;   82	        // // debugBuffer[2] = 'C';
;   83	        // /* Print some scaled font */
;   84	        // gfx_SetTextScale(2, 2);
;   85	        // //gfx_PrintStringXY("This text is SCALED!!", 15, 10);
;   86	        // gfx_PrintStringXY("ahoy", (LCD_WIDTH - gfx_GetStringWidth("ahoy")) / 2, (LCD_HEIGHT - 8) / 2);
;   87	        dbg_sprintf(dbgout, debugBuffer);
;   88	        gfx_SetColor(gfx_white);
	LD	BC,255
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;   89	
;   90	        // for (i = noSegments - 1; i >= 0; i--) {
;   91	        //     gfx_SetColor(i);
;   92	        //     gfx_FillRectangle(segments[0][i], segments[1][i], squareSize, squareSize);
;   93	        // }
;   94	
;   95	        for (i = 0; i < noSegments; i++) {
	LD	BC,0
	LD	(_i),BC
	JR	L_5
L_3:
;   96	            gfx_SetColor(i * 5);
	LD	A,(_i)
	LD	B,A
	LD	C,5
	MLT	BC
	LD	B,0
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;   97	            gfx_FillRectangle(segments[0][i], segments[1][i], squareSize, squareSize);   
	LD	HL,(_i)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,HL
	LD	HL,_segments
	LD	DE,300
	ADD	HL,DE
	LD	DE,BC
	ADD	HL,DE
	LD	DE,(HL)
	LD	HL,(_squareSize)
	PUSH	HL
	LD	HL,BC
	LD	BC,(_squareSize)
	PUSH	BC
	PUSH	DE
	LD	BC,_segments
	ADD	HL,BC
	LD	BC,(HL)
	PUSH	BC
	CALL	_gfx_FillRectangle
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(_i)
	INC	BC
	LD	(_i),BC
;   98	        }
L_5:
	LD	BC,(_noSegments)
	LD	HL,(_i)
	OR	A,A
	SBC	HL,BC
	JR	C,L_3
;   99	
;  100	        gfx_SetColor(gfx_yellow);
	LD	BC,231
	PUSH	BC
	CALL	_gfx_SetColor
	POP	BC
;  101	        gfx_FillCircle(fruitX, fruitY, squareSize / 2);
	LD	HL,(_squareSize)
	LD	BC,2
	CALL	__idivs
	PUSH	HL
	LD	BC,(_fruitY)
	PUSH	BC
	LD	BC,(_fruitX)
	PUSH	BC
	CALL	_gfx_FillCircle
	POP	BC
	POP	BC
	POP	BC
;  102	
;  103	        /* Update kb_Data */
;  104	        kb_Scan();
	CALL	_kb_Scan
;  105	
;  106	        /* Load group 7 registers */
;  107	        key = kb_Data[7];
	LD	A,(16056350)
;  108	
;  109	        switch (key) {
	UEXT	HL
	LD	L,A
	LD	(_key),A
	CALL	__case8
L__1:
	DW	4
	DB	1
	DW24	L_7	

	DB	2
	DW24	L_16	

	DB	4
	DW24	L_10	

	DB	8
	DW24	L_13	

	DW24	L_25	

;  110	            case kb_Down:
L_7:
;  111	                if (currentDir != Up) currentDir = Down;
	LD	HL,(_currentDir)
	CALL	__icmpzero
	JR	Z,L_25
	LD	BC,2
	LD	(_currentDir),BC
;  112	                break;
	JR	L_25
;  113	            case kb_Right:
L_10:
;  114	                if (currentDir != Left) currentDir = Right;
	LD	BC,3
	LD	HL,(_currentDir)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_25
	LD	BC,1
	LD	(_currentDir),BC
;  115	                break;
	JR	L_25
;  116	            case kb_Up:
L_13:
;  117	                if (currentDir != Down) currentDir = Up;
	LD	BC,2
	LD	HL,(_currentDir)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_25
	LD	BC,0
	LD	(_currentDir),BC
;  118	                break;
	JR	L_25
;  119	            case kb_Left:
L_16:
;  120	                if (currentDir != Right) currentDir = Left;
	LD	BC,1
	LD	HL,(_currentDir)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_25
	LD	BC,3
	LD	(_currentDir),BC
;  121	                break;
;  122	            default:
;  123	                break;
;  124	        }
L_25:
;  125	
;  126	        switch ((int)currentDir)
	LD	HL,(_currentDir)
	CALL	__seqcase
L__6:
	DW	4
	DW	0
	DB	0
	DW24	L_20	

	DW24	L_21	

	DW24	L_22	

	DW24	L_23	

	DW24	L_29	

;  127	        {
;  128	        case 0: // up
L_20:
;  129	            yPos-= 2;
	LD	IY,(_yPos)
	LEA	BC,IY+-2
	LD	(_yPos),BC
;  130	            break;
	JR	L_29
;  131	        case 1: // Right
L_21:
;  132	            xPos+= 2;
	LD	IY,(_xPos)
	LEA	BC,IY+2
	LD	(_xPos),BC
;  133	            break;
	JR	L_29
;  134	        case 2: // Down
L_22:
;  135	            yPos+= 2;
	LD	IY,(_yPos)
	LEA	BC,IY+2
	LD	(_yPos),BC
;  136	            break;
	JR	L_29
;  137	        case 3: // Left
L_23:
;  138	            xPos-= 2;
	LD	IY,(_xPos)
	LEA	BC,IY+-2
	LD	(_xPos),BC
;  139	            break;
;  140	        default:
;  141	            break;
;  142	        }
L_29:
;  143	
;  144	        if (yPos > SCREEN_MAX_Y) {
	LD	BC,(_yPos)
	LD	HL,240
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_28
;  145	            yPos = 0;
	LD	BC,0
	LD	(_yPos),BC
;  146	        } else if (yPos < 0) {
	JR	L_33
L_28:
	LD	HL,(_yPos)
	CALL	__icmpzero
	CALL	__setflag
	JP	P,L_33
;  147	            yPos = SCREEN_MAX_Y;
	LD	BC,240
	LD	(_yPos),BC
;  148	        }
L_33:
;  149	
;  150	        if (xPos > SCREEN_MAX_X) {
	LD	BC,(_xPos)
	LD	HL,320
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_32
;  151	            xPos = 0;
	LD	BC,0
	LD	(_xPos),BC
;  152	        } else if (xPos < 0) {
	JR	L_34
L_32:
	LD	HL,(_xPos)
	CALL	__icmpzero
	CALL	__setflag
	JP	P,L_34
;  153	            xPos = SCREEN_MAX_X;
	LD	BC,320
	LD	(_xPos),BC
;  154	        }
L_34:
;  155	        shiftSegments();
	CALL	_shiftSegments
;  156	        segments[0][0] = xPos;
	LD	BC,(_xPos)
;  157	        segments[1][0] = yPos;
	LD	DE,300
	LD	HL,_segments
	ADD	HL,DE
	LD	(_segments),BC
	LD	(IX+-6),HL
	LD	HL,_segments
	LD	BC,300
	ADD	HL,BC
	LD	(IX+-3),HL
	LD	HL,_segments
	ADD	HL,BC
	LD	BC,(_yPos)
	LD	(HL),BC
;  158	
;  159	        if (abs(segments[0][0] - fruitX) < 10 && abs(segments[1][0] - fruitY) < 10) {
	LD	HL,(_segments)
	LD	BC,(_fruitX)
	OR	A,A
	SBC	HL,BC
	PUSH	HL
	CALL	_abs
	POP	BC
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_46
	LD	BC,300
	LD	HL,_segments
	ADD	HL,BC
	LD	HL,(HL)
	OR	A,A
	LD	BC,(_fruitY)
	SBC	HL,BC
	PUSH	HL
	CALL	_abs
	POP	BC
	LD	BC,10
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_46
;  160	            noSegments++;
	LD	BC,(_noSegments)
	INC	BC
	LD	(_noSegments),BC
;  161	            if (noSegments >= maxSegments) {
	LD	BC,(_maxSegments)
	LD	HL,(_noSegments)
	OR	A,A
	SBC	HL,BC
	JR	NC,L_46
;  162	
;  163	            } else {
;  164	                shiftSegments();
	CALL	_shiftSegments
;  165	
;  166	                switch ((int)currentDir)
	LD	HL,(_currentDir)
	CALL	__seqcase
L__14:
	DW	4
	DW	0
	DB	0
	DW24	L_37	

	DW24	L_38	

	DW24	L_39	

	DW24	L_40	

	DW24	L_42	

;  167	                {
;  168	                case 0: // up
L_37:
;  169	                    yPos -= squareSize * 5;
	LD	HL,(_squareSize)
	LD	A,5
	CALL	__imul_b
	LD	BC,HL
	LD	HL,(_yPos)
	LD	DE,BC
	OR	A,A
	SBC	HL,DE
	LD	(_yPos),HL
;  170	                    segments[1][0] -= squareSize * 5;
	LD	HL,_segments
	LD	DE,300
	ADD	HL,DE
	LD	(IX+-9),HL
	LD	HL,(HL)
	LD	IY,(IX+-9)
	OR	A,A
	SBC	HL,BC
	LD	(IY),HL
;  171	                    // yPos--;
;  172	                    break;
	JR	L_42
;  173	                case 1: // Right
L_38:
;  174	                    xPos += squareSize * 5;
	LD	HL,(_squareSize)
	LD	A,5
	CALL	__imul_b
	LD	BC,HL
	LD	DE,BC
	LD	HL,(_xPos)
	ADD	HL,DE
	LD	(_xPos),HL
;  175	                    segments[0][0] += squareSize * 5;
	LD	DE,_segments
	LD	(IX+-12),DE
	LD	HL,(IX+-12)
	LD	HL,(HL)
	ADD	HL,BC
	LD	IY,(IX+-12)
	LD	(IY),HL
;  176	                    // xPos++;
;  177	                    break;
	JR	L_42
;  178	                case 2: // Down
L_39:
;  179	                    yPos += squareSize * 5;
	LD	HL,(_squareSize)
	LD	A,5
	CALL	__imul_b
	LD	BC,HL
	LD	DE,BC
	LD	HL,(_yPos)
	ADD	HL,DE
	LD	(_yPos),HL
;  180	                    segments[1][0] += squareSize * 5;
	LD	HL,_segments
	LD	DE,300
	ADD	HL,DE
	LD	(IX+-15),HL
	LD	HL,(HL)
	ADD	HL,BC
	LD	IY,(IX+-15)
	LD	(IY),HL
;  181	                    // yPos++;
;  182	                    break;
	JR	L_42
;  183	                case 3: // Left
L_40:
;  184	                    xPos -= squareSize * 5;
	LD	HL,(_squareSize)
	LD	A,5
	CALL	__imul_b
	LD	BC,HL
	LD	HL,(_xPos)
	OR	A,A
	SBC	HL,BC
	LD	(_xPos),HL
;  185	                    segments[0][0] -= squareSize * 5;
	LD	DE,_segments
	LD	(IX+-18),DE
	LD	HL,(IX+-18)
	LD	HL,(HL)
	OR	A,A
	SBC	HL,BC
	LD	IY,(IX+-18)
	LD	(IY),HL
;  186	                    // xPos--;
;  187	                    break;
;  188	                default:
;  189	                    break;
;  190	                }
L_42:
;  191	                generateFruit();
	CALL	_generateFruit
;  192	            }
;  193	        }
L_46:
;  194	
;  195	
;  196	
;  197	
;  198	
;  199	        gfx_SwapDraw();
	CALL	_gfx_SwapDraw
;  200	        boot_WaitShort();
	CALL	_boot_WaitShort
;  201	
;  202	    } while (kb_Data[1] != kb_2nd);
	LD	A,(16056338)
	CP	A,32
	JR	NZ,L_47
;  203	    gfx_End();
	CALL	_gfx_End
;  204	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _main ***************************
;Name                         Addr/Register   Size   Type
;_gfx_End                            IMPORT  -----   function
;_boot_WaitShort                     IMPORT  -----   function
;_gfx_SwapDraw                       IMPORT  -----   function
;_maxSegments                        STATIC      3   variable
;_abs                                IMPORT  -----   function
;_shiftSegments                      IMPORT  -----   function
;_xPos                               STATIC      3   variable
;_yPos                               STATIC      3   variable
;_key                                STATIC      1   variable
;_fruitX                             STATIC      3   variable
;_fruitY                             STATIC      3   variable
;_gfx_FillCircle                     IMPORT  -----   function
;_noSegments                         STATIC      3   variable
;_segments                           STATIC    600   variable
;_squareSize                         STATIC      3   variable
;_gfx_FillRectangle                  IMPORT  -----   function
;_i                                  STATIC      3   variable
;_gfx_FillScreen                     IMPORT  -----   function
;_kb_Scan                            IMPORT  -----   function
;_generateFruit                      IMPORT  -----   function
;_gfx_SetTextFGColor                 IMPORT  -----   function
;_gfx_SetColor                       IMPORT  -----   function
;_gfx_SetDraw                        IMPORT  -----   function
;_gfx_Begin                          IMPORT  -----   function
;_currentDir                         STATIC      3   variable
;G_3                                   IX-6      3   variable
;G_1                                   IX-3      3   variable


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


;  205	
;  206	void generateFruit(void) {
_generateFruit:
;  207	    srand(rtc_Time());
	LD	BC,(15925316)
	PUSH	BC
	CALL	_srand
	POP	BC
;  208	    fruitX = rand() % (SCREEN_MAX_X);
	CALL	_rand
	LD	BC,320
	CALL	__irems
	LD	(_fruitX),HL
;  209	    fruitY = rand() % (SCREEN_MAX_Y);
	CALL	_rand
	LD	BC,240
	CALL	__irems
	LD	(_fruitY),HL
;  210	}
	RET	


;**************************** _generateFruit ***************************
;Name                         Addr/Register   Size   Type
;_fruitY                             STATIC      3   variable
;_fruitX                             STATIC      3   variable
;_rand                               IMPORT  -----   function
;_srand                              IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


;  211	
;  212	void shiftSegments(void) {
_shiftSegments:
	LD	HL,-39
	CALL	__frameset
;  213	    for (i = noSegments; i > 0; i--) {
	LD	BC,(_noSegments)
	LD	(_i),BC
	JR	L_55
L_53:
;  214	        segments[0][i] = segments[0][i - 1];
	LD	BC,_segments
	LD	(IX+-6),BC
	LD	DE,(_i)
	DEC	DE
	LD	BC,DE
	LD	HL,3
	CALL	__imulu
	LD	BC,HL
	LD	HL,(_i)
	LD	(IX+-12),BC	; spill
	LD	(IX+-15),HL	; spill
	LD	BC,(IX+-12)	; unspill
	ADD	HL,HL
	LD	(IX+-12),BC	; spill
	LD	BC,(IX+-15)	; unspill
	ADD	HL,BC
	LD	BC,(IX+-12)	; unspill
	LD	(IX+-9),HL
	LD	HL,(IX+-6)
	LD	(IX+-18),BC	; spill
	LD	(IX+-21),BC	; spill
	LD	BC,(IX+-18)	; unspill
	LD	(IX+-18),BC	; spill
	LD	BC,(IX+-21)	; unspill
	ADD	HL,BC
	LD	BC,(IX+-18)	; unspill
	LD	IY,HL
	LD	HL,(IX+-6)
	LD	(IX+-24),BC	; spill
	LD	BC,(IX+-9)
	LD	(IX+-27),BC	; spill
	LD	BC,(IX+-24)	; unspill
	LD	(IX+-24),BC	; spill
	LD	BC,(IX+-27)	; unspill
	ADD	HL,BC
	LD	BC,(IX+-24)	; unspill
	LD	(IX+-30),BC	; spill
	LD	BC,(IY)
	LD	(IX+-33),BC	; spill
	LD	BC,(IX+-30)	; unspill
	LD	(IX+-30),BC	; spill
	LD	BC,(IX+-33)	; unspill
	LD	(HL),BC
	LD	BC,(IX+-30)	; unspill
;  215	        segments[1][i] = segments[1][i - 1];
	LD	HL,_segments
	LD	(IX+-36),BC	; spill
	LD	BC,300
	LD	(IX+-39),BC	; spill
	LD	BC,(IX+-36)	; unspill
	LD	(IX+-36),BC	; spill
	LD	BC,(IX+-39)	; unspill
	ADD	HL,BC
	LD	BC,(IX+-36)	; unspill
	LD	(IX+-3),HL
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IX+-3)
	LD	BC,(IX+-9)
	ADD	HL,BC
	LD	BC,(IY)
	LD	(HL),BC
	LD	(_i),DE
;  216	    }
L_55:
	LD	BC,(_i)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_53
;  217	    // segments[0][0] = xPos;
;  218	    // segments[1][0] = yPos;
;  219	}
	LD	SP,IX
	POP	IX
	RET	


;**************************** _shiftSegments ***************************
;Name                         Addr/Register   Size   Type
;_segments                           STATIC    600   variable
;_i                                  STATIC      3   variable
;_noSegments                         STATIC      3   variable


; Stack Frame Size: 45 (bytes)
;       Spill Code: 0 (instruction)


	XREF _kb_Scan:ROM
	XREF _gfx_SetTextFGColor:ROM
	XREF _gfx_SwapDraw:ROM
	XREF _gfx_SetDraw:ROM
	XREF _gfx_FillCircle:ROM
	XREF _gfx_FillRectangle:ROM
	XREF _gfx_FillScreen:ROM
	XREF _gfx_SetColor:ROM
	XREF _gfx_End:ROM
	XREF _gfx_Begin:ROM
	XREF _abs:ROM
	XREF _rand:ROM
	XREF _srand:ROM
	XREF _boot_WaitShort:ROM
	XREF __idivs:ROM
	XREF __imulu:ROM
	XREF __irems:ROM
	XREF __frameset:ROM
	XREF __setflag:ROM
	XREF __icmpzero:ROM
	XREF __case8:ROM
	XREF __seqcase:ROM
	XREF __imul_b:ROM
	XDEF _shiftSegments
	XDEF _generateFruit
	XDEF _main
	XDEF _currentDir
	XDEF _i
	XDEF _debugBuffer
	XDEF _maxSegments
	XDEF _noSegments
	XDEF _segments
	XDEF _fruitY
	XDEF _fruitX
	XDEF _key
	XDEF _squareSize
	XDEF _yPos
	XDEF _xPos
	END
